/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Handle SPA routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  ({ request, url }: { request: Request; url: URL }) => {
    if (request.mode !== 'navigate') {
      return false;
    }
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache static assets
registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache API responses
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new StaleWhileRevalidate({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  })
);

// Background sync for offline form submissions
const bgSyncPlugin = {
  async requestWillStart({ request }: { request: Request }) {
    const promiseChain = fetch(request.clone());
    return promiseChain;
  },
  async requestWillFail({ request }: { request: Request }) {
    await self.registration.sync.register('sync-forms');
    return null;
  },
};

registerRoute(
  ({ url }) => url.pathname.includes('/assessment/'),
  new StaleWhileRevalidate({
    cacheName: 'assessment-submissions',
    plugins: [bgSyncPlugin],
  })
);

// Handle offline fallback
const FALLBACK_HTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline - OctoFlow</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 2rem;
            text-align: center;
        }
        .offline-message {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
        }
    </style>
</head>
<body>
    <div class="offline-message">
        <h1>You're Offline</h1>
        <p>Please check your internet connection and try again.</p>
        <p>Don't worry - any unsaved changes will be synced when you're back online.</p>
    </div>
</body>
</html>
`;

self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => new Response(FALLBACK_HTML, {
        headers: { 'Content-Type': 'text/html' },
      }))
    );
  }
});

// Handle background sync
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-forms') {
    event.waitUntil(
      (async () => {
        const cache = await caches.open('assessment-submissions');
        const requests = await cache.keys();
        
        await Promise.all(
          requests.map(async (request) => {
            try {
              await fetch(request);
              await cache.delete(request);
            } catch (error) {
              console.error('Background sync failed:', error);
            }
          })
        );
      })()
    );
  }
});

// Handle service worker updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Broadcast channel for communicating with the app
const broadcastChannel = new BroadcastChannel('sw-messages');

// Notify app when offline/online status changes
self.addEventListener('online', () => {
  broadcastChannel.postMessage({ type: 'ONLINE' });
});

self.addEventListener('offline', () => {
  broadcastChannel.postMessage({ type: 'OFFLINE' });
});